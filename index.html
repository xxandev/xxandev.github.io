<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>XXanDev</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif
        }

        body {
            background: #000;
            overflow: hidden;
            position: relative;
            height: 100vh;
            display: flex;
            color: #fff
        }

        .content-container {
            width: 45%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 40px;
            z-index: 10;
            position: relative
        }

        .sphere-section {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000
        }

        .glow {
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(circle at 50% 50%, rgba(0, 100, 180, .02) 0%, rgba(30, 0, 100, .03) 50%, transparent 75%);
            mix-blend-mode: screen;
            opacity: .5
        }

        #instructions {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: rgba(255, 255, 255, .7);
            font-family: sans-serif;
            font-size: 12px;
            background-color: rgba(0, 0, 0, .3);
            padding: 5px 10px;
            border-radius: 3px;
            z-index: 100;
            pointer-events: none;
            line-height: 1.4
        }

        .text {
            position: relative;
            z-index: 10;
            max-width: 500px
        }

        .text h3 {
            font-size: 3.2em;
            font-weight: 700;
            color: #fff;
            line-height: 1.2;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(0, 100, 255, .7)
        }

        .text p {
            font-size: 1.2em;
            color: #e0e0ff;
            margin: 25px 0;
            font-weight: 300;
            line-height: 1.6;
            text-shadow: 0 0 10px rgba(50, 100, 255, .5)
        }

        .buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px
        }

        .text a {
            display: inline-block;
            width: 200px;
            font-size: 1em;
            background: rgba(0, 100, 255, .8);
            padding: 12px 25px;
            text-decoration: none;
            font-weight: 500;
            color: #fff;
            letter-spacing: 1.5px;
            transition: all .3s ease;
            border-radius: 30px;
            box-shadow: 0 0 20px rgba(0, 100, 255, .6);
            text-align: center;
            border: 2px solid rgba(50, 150, 255, .5)
        }

        .text a:hover {
            letter-spacing: 2.5px;
            background: rgba(0, 100, 255, .9);
            transform: translateY(-3px);
            box-shadow: 0 0 25px rgba(0, 100, 255, .8)
        }

        .social {
            position: absolute;
            z-index: 10;
            bottom: 40px;
            left: 40px;
            display: flex;
            align-items: center;
            gap: 15px
        }

        .social li {
            list-style: none
        }

        .social li a {
            display: inline-block;
            transform: scale(.6);
            transition: .5s;
            filter: drop-shadow(0 0 10px rgba(0, 100, 255, .7))
        }

        .social li a:hover {
            transform: scale(.75) translateY(-8px)
        }

        @media (max-width: 991px) {
            body {
                flex-direction: column
            }

            .content-container {
                width: 100%;
                padding: 30px 20px;
                height: 45%
            }

            .sphere-section {
                width: 100%;
                height: 55%
            }

            .text h3 {
                font-size: 2.2em
            }

            .text p {
                font-size: 1em
            }

            .text a {
                font-size: .9em;
                padding: 10px 20px;
                width: 180px
            }

            .social {
                position: relative;
                bottom: 0;
                left: 0;
                margin-top: 30px;
                justify-content: center
            }
        }
    </style>
</head>

<body>
    <div class="content-container">
        <div class="text">
            <h3>Dev House</h3>
            <p>Welcome to my creative development space where ideas come to life through code and innovation.</p>
            <div class="buttons">
                <a href="/menu.html">Projects</a>
                <a href="https://github.com/xxandev">GitHub</a>
            </div>
        </div>
        <ul class="social">
            <li><a href="https://github.com/xxandev"><img src="/styles/ico-white/github.png" alt=""></a></li>
            <li><a href="https://xxandev.github.io"><img src="/styles/ico-white/xxandev.png" alt=""></a></li>
            <li><a href="https://www.youtube.com/channel/UCASgdzzKxwaxUdtDS1HOkyA"><img src="/styles/ico-white/youtube.png" alt=""></a></li>
            <li><a href="/"><img src="/styles/ico-white/telegram.png" alt=""></a></li>
        </ul>
    </div>
    <div class="sphere-section">
        <div id="container"></div>
        <div class="glow"></div>
    </div>
</body>

<script src="/js/lib/threejs/three.min.js"></script>
<script>
    let scene, camera, renderer, particles, stars;
    let time = 0;
    let currentPattern = 0;
    let transitionProgress = 0;
    let isTransitioning = false;

    const screenMouse = new THREE.Vector2(10000, 10000);
    const worldMouse = new THREE.Vector3();
    const raycaster = new THREE.Raycaster();
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const intersectPoint = new THREE.Vector3();
    let canvasRect = { left: 0, top: 0, width: 1, height: 1 };

    let isMouseOverParticles = false;

    const particleCount = 15000;
    const starCount = Math.floor(Math.random() * 4000) + 2000;
    const transitionSpeed = 0.015;

    function createSphere(i, count) {
        const t = i / count;
        const phi = Math.acos(2 * t - 1);
        const theta = 2 * Math.PI * (i / count) * Math.sqrt(count);
        return new THREE.Vector3(
            Math.sin(phi) * Math.cos(theta) * 50,
            Math.sin(phi) * Math.sin(theta) * 50,
            Math.cos(phi) * 50
        );
    }
    function createSpiral(i, count) {
        const t = i / count;
        const numArms = 3;
        const armIndex = i % numArms;
        const angleOffset = (2 * Math.PI / numArms) * armIndex;
        const angle = Math.pow(t, 0.7) * 15 + angleOffset;
        const radius = t * 60;
        const height = Math.sin(t * Math.PI * 2) * 8;
        return new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, height);
    }
    function createGrid(i, count) {
        const sideLength = Math.ceil(Math.cbrt(count));
        const spacing = 80 / sideLength;
        const halfGrid = (sideLength - 1) * spacing / 2;
        const iz = Math.floor(i / (sideLength * sideLength));
        const iy = Math.floor((i % (sideLength * sideLength)) / sideLength);
        const ix = i % sideLength;
        if (ix === Math.floor(sideLength / 2) && iy === Math.floor(sideLength / 2) && iz === Math.floor(sideLength / 2) && sideLength % 2 !== 0) {
            return new THREE.Vector3(spacing * 0.1, spacing * 0.1, spacing * 0.1);
        }
        return new THREE.Vector3(ix * spacing - halfGrid, iy * spacing - halfGrid, iz * spacing - halfGrid);
    }
    function createHelix(i, count) {
        const numHelices = 2;
        const helixIndex = i % numHelices;
        const t = Math.floor(i / numHelices) / Math.floor(count / numHelices);
        const angle = t * Math.PI * 10;
        const radius = 25;
        const height = (t - 0.5) * 80;
        const angleOffset = helixIndex * Math.PI;
        return new THREE.Vector3(Math.cos(angle + angleOffset) * radius, Math.sin(angle + angleOffset) * radius, height);
    }
    function createTorus(i, count) {
        const R = 40, r = 15;
        const a1 = Math.random() * Math.PI * 2;
        const a2 = Math.random() * Math.PI * 2;
        return new THREE.Vector3(
            (R + r * Math.cos(a2)) * Math.cos(a1),
            (R + r * Math.cos(a2)) * Math.sin(a1),
            r * Math.sin(a2)
        );
    }
    const patterns = [createSphere, createSpiral, createHelix, createGrid, createTorus];

    const colorPalettes = [
        [new THREE.Color(0x0077ff), new THREE.Color(0x00aaff), new THREE.Color(0x44ccff), new THREE.Color(0x0055cc)],
        [new THREE.Color(0x8800cc), new THREE.Color(0xcc00ff), new THREE.Color(0x660099), new THREE.Color(0xaa33ff)],
        [new THREE.Color(0x00cc66), new THREE.Color(0x33ff99), new THREE.Color(0x99ff66), new THREE.Color(0x008844)],
        [new THREE.Color(0xff9900), new THREE.Color(0xffcc33), new THREE.Color(0xff6600), new THREE.Color(0xffaa55)],
        [new THREE.Color(0xff3399), new THREE.Color(0xff66aa), new THREE.Color(0xff0066), new THREE.Color(0xcc0055)]
    ];

    function createStarfield() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(starCount * 3);
        const colors = new Float32Array(starCount * 3);
        const starInfo = new Float32Array(starCount);
        const color = new THREE.Color();
        const starRadius = 600;

        for (let i = 0; i < starCount; i++) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            positions[i * 3] = starRadius * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = starRadius * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = starRadius * Math.cos(phi);

            const rand = Math.random();
            if (rand < 0.7) color.setHSL(0, 0, Math.random() * 0.2 + 0.8);
            else if (rand < 0.9) color.setHSL(0.6, 0.7, Math.random() * 0.2 + 0.7);
            else color.setHSL(0.1, 0.7, Math.random() * 0.2 + 0.7);

            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
            starInfo[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('starInfo', new THREE.BufferAttribute(starInfo, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                pointSize: { value: 5.0 }
            },
            vertexShader: `
          attribute float starInfo;
          varying vec3 vColor;
          varying float vStarInfo;
          uniform float pointSize;
          void main(){
            vColor = color;
            vStarInfo = starInfo;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            float atten = clamp(300.0 / max(1.0, -mvPosition.z), 0.5, 6.0);
            gl_PointSize = pointSize * atten;
          }
        `,
            fragmentShader: `
          uniform float time;
          varying vec3 vColor;
          varying float vStarInfo;
          void main(){
            vec2 uv = gl_PointCoord - vec2(0.5);
            float dist = length(uv);
            if (dist > 0.5) discard;

            float speed = vStarInfo * 0.6 + 0.2; 
            float offset = vStarInfo * 6.2831853;
            float twinkle = sin(time * speed + offset) * 0.25 + 0.9;

            float alpha = pow(1.0 - dist * 2.0, 1.2);
            gl_FragColor = vec4(vColor, alpha * twinkle);
          }
        `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexColors: true
        });

        const starPoints = new THREE.Points(geometry, material);
        starPoints.renderOrder = -1;
        return starPoints;
    }

    function createParticleSystem() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const indices = new Float32Array(particleCount);
        const particleTypes = new Float32Array(particleCount);

        const initialPattern = patterns[0];
        const initialPalette = colorPalettes[0];

        for (let i = 0; i < particleCount; i++) {
            indices[i] = i;
            particleTypes[i] = Math.floor(Math.random() * 3);
            const pos = initialPattern(i, particleCount);
            positions[i * 3] = pos.x; positions[i * 3 + 1] = pos.y; positions[i * 3 + 2] = pos.z;

            const colorIndex = Math.floor(Math.random() * initialPalette.length);
            const baseColor = initialPalette[colorIndex];
            const variation = 0.85 + Math.random() * 0.3;
            const finalColor = baseColor.clone().multiplyScalar(variation);
            colors[i * 3] = finalColor.r; colors[i * 3 + 1] = finalColor.g; colors[i * 3 + 2] = finalColor.b;

            sizes[i] = 1.5 + Math.random() * 2.0;
        }

        const posAttr = new THREE.BufferAttribute(positions, 3);
        const colAttr = new THREE.BufferAttribute(colors, 3);
        posAttr.setUsage(THREE.DynamicDrawUsage);
        colAttr.setUsage(THREE.DynamicDrawUsage);

        geometry.setAttribute('position', posAttr);
        geometry.setAttribute('color', colAttr);
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('index', new THREE.BufferAttribute(indices, 1));
        geometry.setAttribute('particleType', new THREE.BufferAttribute(particleTypes, 1));
        geometry.userData.currentColors = new Float32Array(colors);

        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                mousePos: { value: new THREE.Vector3(10000, 10000, 0) },
                mouseActive: { value: 0 }
            },
            vertexShader: `
          uniform float time;
          uniform vec3 mousePos;
          uniform float mouseActive;
          attribute float size;
          attribute float index;
          attribute float particleType;
          varying vec3 vColor;
          varying float vDistanceToMouse;
          varying float vType;
          varying float vIndex;

          float rand(vec2 co){
            return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
          }
          void main(){
            vColor = color;
            vType = particleType;
            vIndex = index;
            vec3 pos = position;
            float T = time * 0.5;
            float idx = index * 0.01;

            float noiseFactor1 = sin(idx * 30.0 + T * 15.0) * 0.4 + 0.6;
            vec3 offset1 = vec3(
              cos(T * 1.2 + idx * 5.0) * noiseFactor1,
              sin(T * 0.9 + idx * 6.0) * noiseFactor1,
              cos(T * 1.1 + idx * 7.0) * noiseFactor1
            ) * 0.4;

            float noiseFactor2 = rand(vec2(idx, idx * 0.5)) * 0.5 + 0.5;
            float speedFactor = 0.3;
            vec3 offset2 = vec3(
              sin(T * speedFactor * 1.3 + idx * 1.1) * noiseFactor2,
              cos(T * speedFactor * 1.7 + idx * 1.2) * noiseFactor2,
              sin(T * speedFactor * 1.1 + idx * 1.3) * noiseFactor2
            ) * 0.8;

            pos += offset1 + offset2;

            if (mouseActive > 0.5){
              vec3 toMouse = mousePos - pos;
              float dist = length(toMouse);
              vDistanceToMouse = 0.0;
              float interactionRadius = 40.0;
              float falloffStart = 8.0;

              if (dist < interactionRadius){
                float influence = smoothstep(interactionRadius, falloffStart, dist);
                vec3 repelDir = normalize(pos - mousePos);
                pos += repelDir * influence * 20.0;
                vDistanceToMouse = influence;
              }
            } else {
              vDistanceToMouse = 0.0;
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            float perspectiveFactor = 700.0 / max(1.0, -mvPosition.z);
            gl_PointSize = size * perspectiveFactor * (1.0 + vDistanceToMouse * 0.5);
          }
        `,
            fragmentShader: `
          uniform float time;
          varying vec3 vColor;
          varying float vDistanceToMouse;
          varying float vType;
          varying float vIndex;

          vec3 rgb2hsl(vec3 c){
            vec4 K = vec4(0.0, -0.3333333, 0.6666667, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
          }
          vec3 hsl2rgb(vec3 c){
            vec4 K = vec4(1.0, 0.6666667, 0.3333333, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }
          void main(){
            vec2 uv = gl_PointCoord * 2.0 - 1.0;
            float dist = length(uv);
            if (dist > 1.0) discard;

            float alpha = 0.0;
            vec3 baseColor = vColor;
            vec3 hsl = rgb2hsl(baseColor);
            float hueShift = sin(time * 0.05 + vIndex * 0.001) * 0.02;
            hsl.x = fract(hsl.x + hueShift);
            baseColor = hsl2rgb(hsl);
            vec3 finalColor = baseColor;

            if (vType < 0.5){
              float core = smoothstep(0.2, 0.15, dist) * 0.9;
              float glow = pow(max(0.0, 1.0 - dist), 3.0) * 0.5;
              alpha = core + glow;
            } else if (vType < 1.5){
              float ringWidth = 0.1;
              float ringCenter = 0.65;
              float ringShape = exp(-pow(dist - ringCenter, 2.0) / (2.0 * ringWidth * ringWidth));
              alpha = smoothstep(0.1, 0.5, ringShape) * 0.8;
              alpha += smoothstep(0.3, 0.0, dist) * 0.1;
            } else {
              float pulse = sin(dist * 5.0 - time * 2.0 + vIndex * 0.1) * 0.1 + 0.9;
              alpha = pow(max(0.0, 1.0 - dist), 2.5) * pulse * 0.9;
            }

            finalColor = mix(finalColor, finalColor * 1.3 + 0.1, vDistanceToMouse * 1.0);
            alpha *= 0.9;
            alpha = clamp(alpha, 0.0, 1.0);
            gl_FragColor = vec4(finalColor * alpha, alpha);
          }
        `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexColors: true
        });

        return new THREE.Points(geometry, material);
    }

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2500);
        camera.position.z = 200;

        renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance',
            preserveDrawingBuffer: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));

        const container = document.getElementById('container');
        if (!container) {
            console.error("HTML element with id 'container' not found!");
            return;
        }

        const canvas = renderer.domElement;
        canvas.style.position = 'absolute';
        canvas.style.left = '50%';
        canvas.style.top = '50%';
        canvas.style.transform = 'translate(-50%, -50%)';
        container.appendChild(canvas);
        canvasRect = canvas.getBoundingClientRect();
        canvas.addEventListener('mousemove', onCanvasMouseMove, { passive: true });
        canvas.addEventListener('mouseleave', onCanvasMouseLeave, { passive: true });
        canvas.addEventListener('mousedown', onMouseClick, { passive: true });
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });

        stars = createStarfield();
        scene.add(stars);

        particles = createParticleSystem();
        scene.add(particles);

        window.addEventListener('resize', onWindowResize, { passive: true });
    }

    function onWindowResize() {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        canvasRect = renderer.domElement.getBoundingClientRect();
    }

    function updateScreenMouse(clientX, clientY) {
        const rect = canvasRect;
        screenMouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        screenMouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
    }

    function onCanvasMouseMove(e) {
        updateScreenMouse(e.clientX, e.clientY);
        checkMouseOverParticles();
    }
    function onCanvasMouseLeave() {
        isMouseOverParticles = false;
        screenMouse.set(10000, 10000);
        if (particles && particles.material.uniforms.mouseActive) {
            particles.material.uniforms.mouseActive.value = 0;
        }
    }
    function checkMouseOverParticles() {
        const boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), 70);
        raycaster.setFromCamera(screenMouse, camera);
        const intersection = raycaster.ray.intersectSphere(boundingSphere, new THREE.Vector3());
        isMouseOverParticles = intersection !== null;
        if (particles && particles.material.uniforms.mouseActive) {
            particles.material.uniforms.mouseActive.value = isMouseOverParticles ? 1 : 0;
        }
    }
    function onMouseClick(e) {
        e.preventDefault();
        if (isMouseOverParticles) forcePatternChange();
    }
    function onTouchStart(e) {
        e.preventDefault();
        if (e.touches.length > 0) {
            updateScreenMouse(e.touches[0].clientX, e.touches[0].clientY);
            checkMouseOverParticles();
            if (isMouseOverParticles) forcePatternChange();
        }
    }
    function onTouchMove(e) {
        e.preventDefault();
        if (e.touches.length > 0) {
            updateScreenMouse(e.touches[0].clientX, e.touches[0].clientY);
            checkMouseOverParticles();
        }
    }

    function forcePatternChange() {
        if (isTransitioning) completeCurrentTransition();
        const nextPattern = (currentPattern + 1) % patterns.length;
        transitionToPattern(nextPattern);
    }

    function completeCurrentTransition() {
        if (!isTransitioning || !particles || !particles.userData.toPositions || !particles.userData.toColors) {
            isTransitioning = false; transitionProgress = 0;
            delete particles?.userData?.fromPositions;
            delete particles?.userData?.toPositions;
            delete particles?.userData?.fromColors;
            delete particles?.userData?.toColors;
            return;
        }
        const positions = particles.geometry.attributes.position.array;
        const colors = particles.geometry.attributes.color.array;
        positions.set(particles.userData.toPositions);
        colors.set(particles.userData.toColors);
        particles.geometry.userData.currentColors = new Float32Array(particles.userData.toColors);
        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        currentPattern = particles.userData.targetPattern;

        delete particles.userData.fromPositions;
        delete particles.userData.toPositions;
        delete particles.userData.fromColors;
        delete particles.userData.toColors;
        isTransitioning = false;
        transitionProgress = 0;
    }

    function transitionToPattern(newPattern) {
        if (!particles) return;
        isTransitioning = true;

        const posAttr = particles.geometry.attributes.position;
        const colAttr = particles.geometry.attributes.color;
        const curPos = new Float32Array(posAttr.array);
        const curCol = particles.geometry.userData.currentColors ?
            new Float32Array(particles.geometry.userData.currentColors) :
            new Float32Array(colAttr.array);

        const newPos = new Float32Array(curPos.length);
        const patternFn = patterns[newPattern];
        for (let i = 0; i < particleCount; i++) {
            const p = patternFn(i, particleCount);
            newPos[i * 3] = p.x; newPos[i * 3 + 1] = p.y; newPos[i * 3 + 2] = p.z;
        }

        const newCol = new Float32Array(curCol.length);
        const palette = colorPalettes[newPattern];
        for (let i = 0; i < particleCount; i++) {
            const idx = Math.floor(Math.random() * palette.length);
            const base = palette[idx];
            const variation = 0.85 + Math.random() * 0.3;
            const final = base.clone().multiplyScalar(variation);
            newCol[i * 3] = final.r; newCol[i * 3 + 1] = final.g; newCol[i * 3 + 2] = final.b;
        }

        particles.userData.fromPositions = curPos;
        particles.userData.toPositions = newPos;
        particles.userData.fromColors = curCol;
        particles.userData.toColors = newCol;
        particles.userData.targetPattern = newPattern;
        transitionProgress = 0;
    }

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        if (!renderer || !camera || !scene) return;

        const deltaTime = clock.getDelta();
        time += deltaTime;
        raycaster.setFromCamera(screenMouse, camera);
        if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
            if (screenMouse.x < 9000) {
                worldMouse.copy(intersectPoint);
            }
        }

        if (stars && stars.material.uniforms.time) {
            stars.material.uniforms.time.value = time;
        }
        if (particles && particles.material.uniforms.time && particles.material.uniforms.mousePos) {
            particles.material.uniforms.time.value = time;
            particles.material.uniforms.mousePos.value.copy(worldMouse);
        }
        if (isTransitioning && particles?.userData.fromPositions && particles.userData.toPositions &&
            particles.userData.fromColors && particles.userData.toColors) {
            transitionProgress += transitionSpeed;
            if (transitionProgress >= 1.0) {
                transitionProgress = 1.0;
                completeCurrentTransition();
            } else {
                const positions = particles.geometry.attributes.position.array;
                const colors = particles.geometry.attributes.color.array;
                const fromPos = particles.userData.fromPositions;
                const toPos = particles.userData.toPositions;
                const fromCol = particles.userData.fromColors;
                const toCol = particles.userData.toColors;
                const t = transitionProgress;
                const ease = t < 0.5 ? 4.0 * t * t * t : 1.0 - Math.pow(-2.0 * t + 2.0, 3.0) / 2.0;

                if (fromPos.length === positions.length && toPos.length === positions.length &&
                    fromCol.length === colors.length && toCol.length === colors.length) {
                    for (let i = 0, n = positions.length / 3; i < n; i++) {
                        const j = i * 3;
                        positions[j] = fromPos[j] * (1 - ease) + toPos[j] * ease;
                        positions[j + 1] = fromPos[j + 1] * (1 - ease) + toPos[j + 1] * ease;
                        positions[j + 2] = fromPos[j + 2] * (1 - ease) + toPos[j + 2] * ease;

                        colors[j] = fromCol[j] * (1 - ease) + toCol[j] * ease;
                        colors[j + 1] = fromCol[j + 1] * (1 - ease) + toCol[j + 1] * ease;
                        colors[j + 2] = fromCol[j + 2] * (1 - ease) + toCol[j + 2] * ease;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                    particles.geometry.attributes.color.needsUpdate = true;
                    particles.geometry.userData.currentColors = new Float32Array(colors);
                } else {
                    console.error("Transition data length mismatch during interpolation!");
                    completeCurrentTransition();
                }
            }
        }

        const baseRadius = 120;
        const radiusVariation = Math.sin(time * 0.1) * 30;
        const cameraRadius = baseRadius + radiusVariation;
        const angleX = time * 0.08;
        const angleY = time * 0.06;
        camera.position.x = Math.cos(angleX) * cameraRadius;
        camera.position.z = Math.sin(angleX) * cameraRadius;
        camera.position.y = Math.sin(angleY) * 50;
        camera.lookAt(0, 0, 0);

        if (stars) { stars.rotation.y += 0.00003; }

        renderer.render(scene, camera);
    }

    function startExperience() {
        init();
        if (renderer) animate();
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startExperience, { once: true });
    } else {
        startExperience();
    }
</script>

</html>